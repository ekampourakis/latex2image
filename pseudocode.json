{
    "pseudocode": [
      {
        "id": "general_simulation",
        "latex": "\\begin{algorithm}\n\\caption{General Simulation Loop}\n\\begin{algorithmic}[1]\n\\State Initialize simulation parameters, particle grid, and configuration\n\\For{each simulation step}\n    \\If{(UsePause is true) and (system has converged)}\n        \\State \\textbf{return} \\Comment{Skip simulation update}\n    \\EndIf\n    \\For{each spring in the system}\n         \\State Apply spring forces (see Section 3.2.2.2)\n    \\EndFor\n    \\If{collision handling is enabled}\n         \\State Invoke Collision Handling Routine (see Section 3.2.3)\n    \\EndIf\n    \\For{each particle}\n         \\State Update particle position using Verlet Integration:\n         \\[\n         \\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + (\\mathbf{r}(t)-\\mathbf{r}(t-\\Delta t)) \\cdot D + \\frac{\\mathbf{F}(t)}{m}\\,\\Delta t^2\n         \\]\n    \\EndFor\n    \\For{each constraint iteration}\n         \\For{each constraint in the current bin}\n              \\State Compute current distance and check threshold\n              \\If{constraint is violated}\n                  \\State Adjust positions using:\n                  \\[\n                  \\Delta \\mathbf{r} = \\left(1 - \\frac{L_0}{L}\\right) \\cdot C \\cdot (\\mathbf{r}_1 - \\mathbf{r}_2)\n                  \\]\n              \\EndIf\n         \\EndFor\n    \\EndFor\n    \\State Update simulation state (calculate dip, check convergence, etc.)\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}",
        "auto_align": true
      },
      {
        "id": "collision_handling",
        "latex": "\\begin{algorithm}\n\\caption{Collision Handling Routine}\n\\begin{algorithmic}[1]\n\\For{each collision shape in the system}\n    \\For{each particle}\n         \\If{particle is non-static}\n              \\If{particle lies within the shape's bounding volume}\n                  \\State Determine collision primitive (plane, disk, sphere, box, mesh)\n                  \\If{collision is detected}\n                        \\State Compute collision normal \\(\\mathbf{n}\\) and penetration depth \\(d\\)\n                        \\State Adjust particle force:\n                        \\[\n                        \\mathbf{F}_{\\text{collision}} = - k_{\\text{col}}\\, d\\, \\mathbf{n}\n                        \\]\n                        \\State Update particle response using friction adjustment:\n                        \\[\n                        \\mathbf{F}_{\\text{adjusted}} = \\mathbf{F} - \\left(\\mathbf{F} \\cdot \\mathbf{n}\\right)\\mathbf{n}\n                        \\]\n                  \\EndIf\n              \\EndIf\n         \\EndIf\n    \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}",
        "auto_align": true
      },
      {
        "id": "particle_constraint",
        "latex": "\\begin{algorithm}\n\\caption{Particle Update and Constraint Satisfaction}\n\\begin{algorithmic}[1]\n\\For{each particle}\n    \\If{particle is non-static and not bitmapped}\n         \\State Save current position \\(\\mathbf{r}_{\\text{old}}\\)\n         \\State Compute new position using Verlet Integration:\n         \\[\n         \\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + (\\mathbf{r}(t)-\\mathbf{r}(t-\\Delta t)) \\cdot D + \\frac{\\mathbf{F}(t)}{m}\\,\\Delta t^2\n         \\]\n         \\If{new position violates motion speed constraints}\n             \\State Limit displacement accordingly\n         \\EndIf\n         \\State Set previous position \\(\\mathbf{r}(t-\\Delta t) = \\mathbf{r}_{\\text{old}}\\)\n         \\State Reset force to baseline gravity: \\(\\mathbf{F} \\leftarrow (0, 0, -g \\; m)\\)\n    \\EndIf\n\\EndFor\n\\For{each constraint between particle \\(i\\) and \\(j\\)}\n    \\State Compute vector \\( \\mathbf{v} = \\mathbf{r}_i - \\mathbf{r}_j \\)\n    \\State Compute current distance \\( L = \\|\\mathbf{v}\\| \\)\n    \\If{\\( L > \\lambda L_0 \\)} \\Comment{If beyond allowed threshold}\n         \\State Calculate adjustment:\n         \\[\n         \\Delta \\mathbf{r} = \\left(1 - \\frac{L_0}{L}\\right) C \\; \\mathbf{v}\n         \\]\n         \\State Adjust positions: \n         \\[\n         \\mathbf{r}_i \\leftarrow \\mathbf{r}_i - \\Delta \\mathbf{r} \\quad \\text{and} \\quad \\mathbf{r}_j \\leftarrow \\mathbf{r}_j + \\Delta \\mathbf{r}\n         \\]\n    \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}",
        "auto_align": true
      },
      {
        "id": "gpu_cpu_communication",
        "latex": "\\begin{algorithm}\n\\caption{CPU-GPU Communication and Processing}\n\\begin{algorithmic}[1]\n\\State \\textbf{// Transfer data from CPU to GPU:}\n\\State ToGPU(particles, springs, constraints, collision\\_shapes)\n\\State \\textbf{// Launch CUDA kernel for applying spring forces}\n\\State LaunchKernel(CUDASpring, particles, springs, config, numThreads)\n\\If{collision handling is enabled}\n    \\State \\textbf{// Launch CUDA kernel for collision handling on various shapes}\n    \\State LaunchKernel(CUDACollide, particles, collision\\_shapes, config, numThreads)\n\\EndIf\n\\State \\textbf{// Launch CUDA kernel for Verlet integration}\n\\State LaunchKernel(CUDAVerlet, particles, config, numThreads)\n\\For{each constraint iteration}\n    \\State LaunchKernel(CUDAConstraint, particles, constraints, config, numThreads)\n\\EndFor\n\\State \\textbf{// Transfer updated particle data back from GPU to CPU:}\n\\State FromGPU(particles)\n\\end{algorithmic}\n\\end{algorithm}",
        "auto_align": true
      },
      {
        "id": "cuda_kernel_integration",
        "latex": "\\begin{algorithm}\n\\caption{CUDA Kernel for Particle Integration and Collision (Simplified)}\n\\begin{algorithmic}[1]\n\\For{each thread index $idx$ in parallel}\n    \\If{$idx < $ numParticles}\n         \\State Compute net force for particle $idx$ using:\n         \\[\n         \\mathbf{F}(idx) = \\mathbf{F}_{\\text{spring}}(idx) + \\mathbf{F}_{\\text{gravity}} + \\mathbf{F}_{\\text{collision}}(idx)\n         \\]\n         \\State Update particle position using Verlet integration:\n         \\[\n         \\mathbf{r}(idx,t+\\Delta t) = \\mathbf{r}(idx,t) + (\\mathbf{r}(idx,t)-\\mathbf{r}(idx,t-\\Delta t)) \\cdot D + \\frac{\\mathbf{F}(idx)}{m} \\Delta t^2\n         \\]\n         \\State Apply local collision corrections if necessary\n    \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}",
        "auto_align": true
      }
    ]
  }